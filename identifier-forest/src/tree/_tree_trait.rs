//! Defines the API for a tree

// This file is formated in a format that is easy to parse

use crate::Identifier;

/// An iterator over an array of 4 identifiers
pub type Tree4Iterator<'a, I> = Box<dyn Iterator<Item = [I; 4]> + 'a>;

/// A structure that can be instanciated by forcing it to be a real structure
/// or that can be lazy, depending on the used constructor.
///
/// It also does not require extra parameters.
pub trait LazyStructure
{
    /// Builds an instance.
    fn new() -> Self;

    /// Builds an instance. The instance must be able to receive data.
    fn new_instanciated() -> Self;
}

/// A queryable tree. On initialization, it is not required to be able to
/// receive new data.
///
/// The tree may not exist, but should be spawnable.
/// 
/// Trees are not actually enforced: implementing this trait using a sorted
/// array would be a valid implementation.
pub trait MaybeTree4<I>
where I: Identifier
{
    /// Return true if this true is able to store data
    fn exists(&self) -> bool;

    /// If this tree is not yet instanciated, builds a new tree and populate it
    /// with the data generated by f
    fn ensure_exists<'a, F>(&self, f: F) where F: FnOnce() -> Tree4Iterator<'a, I>;

    /// Return an iterator on every quads in the tree, that matches the given
    /// pattern.
    ///
    /// - Precondition: exists() returns true
    /// - Implementations can actually modify the inner state of the object
    /// (for caching / indexing purposes), as long as the contained quads
    /// remains the same.
    fn get_quads<'a>(&'a self, pattern: [Option<I>; 4]) -> Tree4Iterator<'a, I>;

    /// Return the index conformance (TODO)
    ///
    /// If can_build is true the result is always something, else it is None if
    /// this tree does not exists yet.
    fn index_conformance(&self, can_build: bool, pattern_layout: &[Option<I>; 4]) -> Option<usize>;

    /// Eventually insert the quad, Returns true if the quad wasn't already present.
    /// If the set did not have this value present, true is returned.
    fn insert(&mut self, id_quad: &[I; 4]) -> Option<bool>;

    /// Eventually delete the quads. 
    fn delete(&mut self, id_quad: &[I; 4]) -> Option<bool>;

    /// Return the number of stored quads
    fn size(&self) -> Option<usize>;

    /// Return true if the quad is in the tree
    fn has(&self, id_quad: &[I; 4]) -> Option<bool>;

    // _generator_tree_enum.py: StartIgnore

    /// Return every quads stored in the tree.
    ///
    /// Equivalent to `get_quads([None, None, None, None])`
    fn iter<'a>(&'a self) -> Tree4Iterator<'a, I> {
        self.get_quads([None, None, None, None])
    }

    // _generator_tree_enum.py: EndIgnore
}

/// A [`MaybeTree4`] which supports some ensemblist operations
pub trait BinaryMaybe4TreeOperations<I>
: MaybeTree4<I>
where I: Identifier
{
    /// Compute the intersection of the quads in this tree and in `other`.
    ///
    /// If one of the tree does not [exist](MaybeTree4::exists), the result
    /// should not exist.
    fn intersect(&self, other: &Self) -> Self;

    /// Compute the union of the quads in this tree and in `other`.
    ///
    /// If one of the tree does not [exist](MaybeTree4::exists), the result
    /// should not exist.
    fn union(&self, other: &Self) -> Self;

    /// Compute the different of the quads in this tree and in `other`.
    ///
    /// If one of the tree does not [exist](MaybeTree4::exists), the result
    /// should not exist.
    fn difference(&self, other: &Self) -> Self;

    /// Check if every quads in other are in this tree.
    ///
    /// If one of the tree does not [exist](MaybeTree4::exists), the result
    /// should be None
    fn contains(&self, other: &Self) -> Option<bool>;
}

pub trait Forest4<I>: MaybeTree4<I>
where I: Identifier {

    /// Number of currently instanciated underlying trees. 
    fn get_number_of_living_trees(&self) -> usize;

    /// Ensure the optimal tree in this forest for a request of the given
    /// pattern is built.
    fn ensure_has_index_for(&self, pattern: &[Option<I>; 4]);

    /// Return an iterator on every quads in the tree, that matches the given
    /// pattern. No new tree will be built from this function call, meaning the
    /// forest should really remain non mutable.
    ///
    /// In other words, a call to
    /// [`get_quads_unamortized()`] should not be amortized and the number
    /// [living trees](get_number_of_living_trees()) should not change between
    /// two calls.
    fn get_quads_unamortized<'a>(&'a self, pattern: [Option<I>; 4]) -> Tree4Iterator<'a, I>;
}
